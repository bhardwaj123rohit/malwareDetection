package malwaredetectionandroid;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.StringTokenizer;



public class train {
	public static int  MaxHashFreq=400;//M
	public static int MaxHashVal=900;//N
	public static int NoOfData=188;
	
	kernel k;
	int defaultHist[]=new int[MaxHashVal];
	double input[][]=new double[NoOfData][MaxHashFreq*MaxHashVal];
	double yinput[]=new double[NoOfData];
	double b=3.0;
	
	double theta[]=new double[MaxHashFreq*MaxHashVal];
	
	
	public train() {
		
	//Finding default Histogram
		 BufferedReader br2;
		try {
			br2 = new BufferedReader(new FileReader("default.txt"));
			 String line2 = br2.readLine();
			 StringTokenizer token =new StringTokenizer(line2, " ");
		    	token.nextToken();
		    	int j=0;
		    	
		    	while(token.hasMoreTokens()&&j<900)
		    	{
		    		defaultHist[j++]=Integer.parseInt( token.nextToken());
		    		
		    		
		    		
		    	}
		    	
		    	br2.close();
                        
                       br2= new BufferedReader(new FileReader("theta.txt"));
                     line2 = br2.readLine();
			  token =new StringTokenizer(line2, " ");
		    		j=0;    	
		    	while(token.hasMoreTokens())
		    	{
		    		theta[j++]=Double.parseDouble( token.nextToken());
		    		
		    		
		    		
		    	}
			 
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		    
        
         
		
		k= new kernel(defaultHist, MaxHashVal, MaxHashFreq);
		
		
		
		
		
	}// end of constructor
	
/*
	public void loaddata() throws FileNotFoundException, IOException
	{
		int i =0 ;
		
		for(int k=0;k<2;k++)
		{
		try(BufferedReader br = new BufferedReader(new FileReader("C:\\Users\\Sony\\Downloads\\hashes2.txt"))) {
		    String line = br.readLine();
		    while(line!=null)
		    {
		    	StringTokenizer token =new StringTokenizer(line, " ");
		    	token.nextToken();
		    	int j=0;
		    	
		    	while(token.hasMoreTokens()&&j<900)
		    	{
		    		input[i][j++]=Integer.parseInt( token.nextToken());
		    		
		    		
		    		
		    	}
		    	
		    	line=br.readLine();
		    	
		    		yinput[i]=0.0;
		    		i++;
		    	
		    	
		    	
		    }
		    i--;
		    
		        BufferedReader br2 = new BufferedReader(new FileReader("C:\\Users\\Sony\\Downloads\\fakeinstaller.txt"));
		    
		         String line2 = br2.readLine();
				    while(line2!=null)
				    {
				    	StringTokenizer token =new StringTokenizer(line2, " ");
				    	token.nextToken();
				    	int j=0;
				    	
				    	while(token.hasMoreTokens()&&j<900)
				    	{
				    		input[i][j++]=Integer.parseInt( token.nextToken());
				    		
				    		
				    		
				    	}
				    	
				    	line2=br2.readLine();
				    	
				    		yinput[i]=1.0;
				    		i++;
				    	
				    	
				    	
				    }
				    
				    br2.close();
				         
		         
		    }catch(Exception ex){
		    	
		    	System.out.println("Error");
		    }
		
		}
		for(double y:yinput)
			System.out.println( y );
		    
		}		
		
	
 
    
    public double signoid(double x)
    {
 
        return  (1 / (1 + Math.pow( Math.E , -x )));
    }
    
    public double hypothesis(double wei[],double data[])
    {
            double h=0;
    double dotp=0;
    for(int i=0; i < data.length; i++ )    
                dotp+=wei[i]*data[i];
      //  System.err.println("dotp :"+dotp);
    
             h=signoid(dotp);
        //     System.err.println("signoid :"+h);
             return h;
    
    }
    
    
    public double findcost(double wei[],double data[],double y)
    {
    
  
        double h;
        h = hypothesis(wei,data);
      
           if(h==0.0)
               h=0.000000000000000000000000000001;
            if(h==1.0)
                  h=.999999989898986666789863563632;
        
        double k=y*(-Math.log(h))- (1-y)*Math.log((1-h)) ;
      //      System.out.println("k :"+k );
        if(Double.isNaN(k)||Double.isInfinite(k)) 
        {
            System.out.println(k+" "+h);
        k=0.0;
        
        }
        return  k;
   
    }
    
    
  
	
	
	
	public void trainer() {
		 QNMinimizer minimizer =new QNMinimizer(5, true);
	      
		    
		    
		        theta=minimizer.minimize(new minopti(),.00001 , theta,100);
		
	}
	
	  public  class minopti implements edu.stanford.nlp.optimization.DiffFunction
	    {
	       	        
	        
	        @Override
	        public double[] derivativeAt(double[] x) {
	            double [] k=new double[MaxHashFreq*MaxHashVal];
	          
	           
	    double m=0;
	    double[] rtheta=new double[MaxHashFreq*MaxHashVal];
	    for(int b=0;b<NoOfData;b++)
	    {
	    rtheta[b]=(hypothesis(x,input[b])-yinput[b]);
	    
	    }
	    
	    for(int col=0;col<MaxHashFreq*MaxHashVal ;col++){
	        for(int b=0;b<NoOfData;b++) {
	            
	            k[col] +=   rtheta[b]* input[b][col];
	           
	           }
	    }
	           
	       //for(int b=0; b < vc.vocab.length; b++ )   
	         //  k[b]= (x[b]*m);
	 
	      // for(double mn:k )
	        //        System.out.println(mn +" ");
	       
	       
	       return k;
	        
	        }

	        @Override
	        public double valueAt(double[] x) {
	           double cost=0,thetacost=0;
	        
	       for(int b=0;b<NoOfData;b++)
	       {
	        
	           cost+= findcost(x, input[b], yinput[b]);
	        
	       }
	       
	       for(int b=0;b<theta.length;b++)
	           thetacost+=theta[b]*theta[b];
	           
	       thetacost/=2;
	           // System.out.println(100*cost);
	       //return cost;
	       return cost+thetacost;
	        }

	        @Override
	        public int domainDimension() {
	             return MaxHashFreq*MaxHashVal;
	           
	        }
	    }
	    
	  
	*/

}
